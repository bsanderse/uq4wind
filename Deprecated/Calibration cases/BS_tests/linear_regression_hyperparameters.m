%% Linear model calibration:
% comparison of methods
% - OLS
% - UQLab
% - Implicit quadrature rule

clc
close all
clearvars

rng default

% select which methods to run
% runOLS = 1; % Ordinary Least Squares
runUQLab = 1; % UQLab
% runIQR = 0; % Implicit quadrature rule
% runSampling = 0; % Brute-force sampling of prior

calibrate_sigma = 1; % calibrate hyperparameter


%% input settings
p = 2; % dimension of parameters to be calibrated
N_data = 160; % dimension of data vector

dom = [0,2]; % domain of x

%% plot settings
fontsize = 14;
fontname = 'Helvetica';
set(0,'defaultlinelinewidth',2)

%% generate data and exact solution

% generate artificial measurement data by using the linear model
% with Gaussian noise on top of it

x_data = linspace(dom(1),dom(2),N_data)';

% stdev in measurement error - also used for likelihood in Bayes
sigma = 0.1;

% exact value for beta is only used to generate artificial measurement data, and to
% plot exact solution
beta_exact = [0.4;0.6]; % should have length p

% measurement data
z_data  = linearmodel(beta_exact,x_data) + sigma*randn(N_data,1);

% generate exact solution for plotting purposes
N_exact = 100;
x_exact = linspace(dom(1),dom(2),N_exact)';
y_exact = linearmodel(beta_exact,x_exact);

% exact solution for Bayes:
% - multivariate normal likelihood, with mean = 0 and covariance sigma^2 * I
% - uniform prior
% the posterior MAP estimate should then be the same as the OLS estimate

% we now create the design matrix, built with the x_data points
% we create it automatically by calling linearmodel several times,
% each time with only one of the betas active
p = length(beta_exact);
A = zeros(N_data,p); % size of design matrix, normally N_data>p
beta_test = eye(p,p);
for i=1:p
    A(:,i) = linearmodel(beta_test(:,i),x_data);
end

figure(1)
set(gcf,'DefaultAxesFontSize',fontsize,'DefaultAxesFontName',fontname);
plot(x_data,z_data,'x');
hold on
plot(x_exact,y_exact,'-');
legend('data','exact solution for generating synthetic data');


%% Bayesian solution with UQLab
if (runUQLab == 1)
    
    %% initialize UQlab
    
    % add path
    addpath(genpath('../../../UQLabCore_Rel1.3.0/'));
    % start uqlab
    uqlab
    
    % model settings
    ModelOpts.mFile = 'linearmodel_vectorized';
    % pass design matrix as parameter to the M-file
    ModelOpts.Parameters   = A;
    ModelOpts.isVectorized = true;
    myForwardModel = uq_createModel(ModelOpts);
    
    % prior
    PriorOpts.Marginals(1).Name = 'beta0';
    PriorOpts.Marginals(1).Type = 'Uniform';
    PriorOpts.Marginals(1).Parameters = [0,1];
    %
    PriorOpts.Marginals(2).Name = 'beta1';
    PriorOpts.Marginals(2).Type = 'Uniform';
    PriorOpts.Marginals(2).Parameters = [0,1];
    %
    myPriorDist = uq_createInput(PriorOpts);
    
    
    % display input properties
    % uq_print(myPriorDist);
    % uq_display(myPriorDist);
    
    
    %% likelihood
    if (calibrate_sigma ==0)
        % known variance:
        DiscrepancyOpts.Type = 'Gaussian';
        DiscrepancyOpts.Parameters = sigma^2; % this is sigma^2
        
    elseif (calibrate_sigma ==1)
        % unknown variance
        DiscrepancyPriorOpts.Name = 'Prior of discrepancy';
        DiscrepancyPriorOpts.Marginals.Name = 'Sigma2';
        DiscrepancyPriorOpts.Marginals.Type = 'Uniform';
        DiscrepancyPriorOpts.Marginals.Parameters = [0, 2*var(x_data)]; %[0, mean(x_data).^2];
        myDiscrepancyPrior = uq_createInput(DiscrepancyPriorOpts);
        DiscrepancyOpts.Prior = myDiscrepancyPrior;
        DiscrepancyOpts.Type  = 'Gaussian';
    end
    
    %% Bayes options
    Solver.Type = 'MCMC';
    % Adaptive Metropolis:
    Solver.MCMC.Sampler = 'AM';
    Solver.MCMC.Steps = 1e3;
    Solver.MCMC.NChains = 1e2;
    Solver.MCMC.T0 = 1e2;
    %     Solver.MCMC.Proposal.PriorScale = 0.1;
    % AIES:
    %     Solver.MCMC.Sampler = 'AIES';
    
    % show MCMC chain convergence:
    %     Solver.MCMC.Visualize.Parameters = 1;
    %     Solver.MCMC.Visualize.Interval = 100;
    
    myData.y       = z_data'; % note: UQLab uses a row vector here
    myData.Name    = 'measurement data';
    BayesOpts.Prior = myPriorDist;
    BayesOpts.Data = myData;
    BayesOpts.Type = 'Inversion';
    BayesOpts.Discrepancy = DiscrepancyOpts;
    BayesOpts.Solver = Solver;
    
    %% perform MCMC
    myBayesianAnalysis = uq_createAnalysis(BayesOpts);
    
    %% postprocessing

    % text output of Bayesian analysis
    uq_print(myBayesianAnalysis)
    % graphical display of posterior
    uq_display(myBayesianAnalysis,'trace','all')
    
%     uq_postProcessInversion(myBayesianAnalysis,'burnIn',0.5,'posteriorPredictive',1000);

    % All post-processing results generated by the uq_postProcessInversion function are stored
    % in the myBayesianAnalysis.Results.PostProc structure.
    
    % get the Maximum a Posteriori value
    uq_postProcessInversion(myBayesianAnalysis,'pointestimate','Mean');
    beta_UQLab_mean = myBayesianAnalysis.Results.PostProc.PointEstimate.X
    % get the mean posterior value
    uq_postProcessInversion(myBayesianAnalysis,'pointEstimate', 'MAP');
    beta_UQLab_MAP = myBayesianAnalysis.Results.PostProc.PointEstimate.X
    
    y_UQLab_MAP = linearmodel(beta_UQLab_MAP',x_exact);
    y_UQLab_mu  = myBayesianAnalysis.Results.PostProc.PostPred.model.pointEstimateRun; % posterior predictive
    
    figure(1)
    hold on
    plot(x_data,y_UQLab_mu,'-.');
    legappend('UQLab posterior predictive (mean)')
    
    


    
end


%%
figure(1)
grid on
xlabel('x')
ylabel('y')

