function [Y_mu, Y_sigma, Y_Cov] = uq_Kriging_eval(current_model, X0)% UQ_KRIGING_EVAL(CURRENT_MODEL,X0) evaluates the response of the Kriging% metamodel CURRENT_MODEL (Kriging predictor) onto the vector of inputs X0%% Y_mu = UQ_KRIGING_EVAL(...) returns the mean of the Kriging predictor%% [Y_mu, Y_sigma] = UQ_KRIGING_EVAL(...) additionally returns the variance% of the Kriging predictor%% [Y_mu, Y_sigma,Y_Cov] = UQ_KRIGING_EVAL(...) additionally returns the% full covariace matrix of the predictor's output%% See also: UQ_KRIGING_CALCULATE, UQ_EVAL_UQ_METAMODEL, UQ_PCE_EVAL% do nothing if X0 is emptyif isempty(X0)    Y_mu = [];    Y_sigma = [];    return;end% get dimensions of X0[N0, M0] = size(X0);% make sure that X0 dimensions are consistent with the experimental designif M0 ~= current_model.Internal.Runtime.M   error('Inconsistent dimensions of supplied input with respect to the experimental design!') end%% Keep track of the requested outputs% Raise a flag to calculate the predictor variance only if its requestedif nargout >= 2    CALC_SIGMASQ_TRUE = 1;else    CALC_SIGMASQ_TRUE = 0;end% Raise a flag to calculate the predictor variance only if its requestedif nargout >= 3    CALC_FULL_COV = 1;else    CALC_FULL_COV = 0;end%% Make sure that current_model is calculatedif  ~current_model.Internal.Runtime.isCalculated    uq_calculateMetamodel(current_model);end%% Map X0 to the appropriate space to get U0SCALING = current_model.Internal.Scaling;SCALING_BOOL = isa(SCALING, 'double') || isa(SCALING, 'logical') || isa(SCALING, 'int');        if SCALING_BOOL && SCALING    muX = current_model.Internal.ExpDesign.muX;    sigmaX = current_model.Internal.ExpDesign.sigmaX;    U0 = bsxfun(@rdivide,(bsxfun(@minus,X0,muX)), sigmaX);elseif SCALING_BOOL && ~SCALING    U0 = X0;endif ~SCALING_BOOL    % In that case SCALING is an INPUT object. An isoprobabilistic    % transform is performed from:    % current_model.Internal.Input    % to:    % current_model.Internal.Scaling        U0 =  uq_GeneralIsopTransform(X0,...        current_model.Internal.Input.Marginals, current_model.Internal.Input.Copula,...        SCALING.Marginals, SCALING.Copula);end%% Retrieve necessary matricesF = current_model.Internal.Kriging(1).Trend.F ;U = current_model.ExpDesign.U ;%% filter out the constants from the experimental designnonConstIdx = current_model.Internal.Runtime.nonConstIdx;U0 = U0(:,nonConstIdx);U = U(:,nonConstIdx);%% Initialize predictor output% Store the input and output size to some local variablesNout = current_model.Internal.Runtime.Nout;N0 = size(U0,1);Y_mu = zeros(N0,Nout) ;if CALC_SIGMASQ_TRUE    Y_sigma = zeros(N0,Nout) ;    if CALC_FULL_COV        Y_Cov = zeros(N0,N0,Nout) ;    endend%% calculate f0 (trend value for the input U0)evalF_handle = current_model.Internal.Kriging(1).Trend.Handle ;f0 = evalF_handle(U0, current_model) ;%% cycle through each outputfor oo = 1 : Nout    % Retrieve necessary matrices    theta = current_model.Internal.Kriging(oo).Optim.Theta ;    beta = current_model.Internal.Kriging(oo).Trend.beta ;    R = current_model.Internal.Kriging(oo).GP.R;    evalR_handle = current_model.Internal.Kriging(oo).GP.Corr.Handle ;    Y = current_model.ExpDesign.Y(:,oo) ;        % Calculate auxiliary matrices if the cache is empty    if isempty(current_model.Internal.Kriging(oo).Cached)        auxMatrices = uq_Kriging_calc_auxMatrices( R, F, Y, 'default' );    else        auxMatrices = current_model.Internal.Kriging(oo).Cached;    end        % Retrieve additionally some already computed matrices that will be used    % later:     FTRinvF = auxMatrices.FTRinvF ;%= (F'*Rinv*F)    FTRinv = auxMatrices.FTRinv ;%= (F'*Rinv)    %% Perform Kriging prediction    r0 = evalR_handle( U0, U, theta,  current_model.Internal.Kriging(oo).GP.Corr );        % Y_mu = f0*beta + r0* (R\ (transpose(Y) - F*beta)) ;    if isnan(auxMatrices.cholR)        Rinv = auxMatrices.Rinv ; %pseudo-inverse of R        Y_mu(:,oo) = f0*beta + r0* Rinv * (Y - F*beta) ;    else        L = auxMatrices.cholR ;        Y_mu(:,oo) = f0*beta + r0* (L\ (transpose(L) \ (Y - F*beta)) );    end    if CALC_SIGMASQ_TRUE        u0 = FTRinv * transpose(r0) - transpose(f0) ;                if ~CALC_FULL_COV            % Compute the part : r0* R^(-1)* transpose(r0)            % Note: We only need the  diagonal elements of the resulting matrix!            D1 = uq_Kriging_diag_of_congruent( r0, R ) ;            % Compute the part : u0* (transpose(F) * R^(-1) *F) ^(-1) * u0            % Note: We only need the diagonal elements of the resulting matrix!            D2 = uq_Kriging_diag_of_congruent( u0, FTRinvF ) ;                        % Finally calculate the MSE (Mean Squared Error) of the predictions            Y_sigma_oo = (ones(size(D1)) -D1 + D2) * current_model.Internal.Kriging(oo).GP.sigmaSQ ;        else            % Compute the part : r0* R^(-1)* transpose(r0)            % Note: We only need the  diagonal elements of the resulting matrix!            % Y_mu = f0*beta + r0* (R\ (transpose(Y) - F*beta)) ;            if any(isnan(auxMatrices.cholR(:)))                Rinv = auxMatrices.Rinv ; %pseudo-inverse of R                D1 = r0*Rinv*r0.';            else                L = auxMatrices.cholR ;                D1 = r0*(L\ (transpose(L)\r0.'));            end            % Compute the part : u0* (transpose(F) * R^(-1) *F) ^(-1) * u0            % Note: We only need the diagonal elements of the resulting matrix!            D2 = u0.'*(FTRinvF\u0);                        % Finally calculate the the full covariance matrix            CorrU0 = evalR_handle( U0, U0, theta,  current_model.Internal.Kriging(oo).GP.Corr );            Y_Cov_oo = (CorrU0 -D1 + D2) * current_model.Internal.Kriging(oo).GP.sigmaSQ ;            Y_sigma_oo = diag(Y_Cov_oo);            Y_Cov(:,:,oo) = Y_Cov_oo;        end                if any(Y_sigma_oo < 0)            warning('Numerical dispersion: calculated sigma has negative value for %d out of %d predicted values!!', sum(Y_sigma_oo < 0), numel(Y_sigma));        end                % Warning: Buffer underflow possible, needs fixing!        Y_sigma(:,oo) = max(0, Y_sigma_oo);            end        %% clean cache if requested    if ~current_model.Internal.KeepCache        current_model.Internal.Kriging(oo).Cached = [];    endend