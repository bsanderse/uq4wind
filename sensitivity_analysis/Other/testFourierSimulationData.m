%% test Fourier representation of azimuth-dependent data
clearvars
close all

%% load some simulation data
root_folder = pwd;
filename = fullfile('AEROmodule','NewMexico_calibrate','current','output','B1n_BEM.txt');

% Read output data generated by AeroModule
D = readtable(filename,'HeaderLines', 4,"ReadVariableNames",true,...
    "PreserveVariableNames",true); % Reads the variable data from the
% specified .txt file
% column 1 is time,
% column 2 is azimuth,
% columns 3:end correspond to different radial locations
Fn = D{:,3:end};

% Radial stations
r_sim = str2double(D.Properties.VariableNames(3:end));
% the radial stations are expressed in % of the blade length,
% excluding the hub radius
% to compare to experiments, add the hub radius:
r_sim = r_sim + 0.21;


%% get a number of revolutions
n_rev = 4;

% radial stations of experimental data
r_exp = [0.25 0.35 0.6 0.82 0.92]*2.25;

% Use full (azimuth dependent) solution
% select a couple of revolutions by looking at where azimuth is smaller
% than a threshold value; the threshold value is taken as the minimum of the difference
% between azimuth angles
azi_sim       = D{:,2};
delta_azi     = floor(min(abs(diff(azi_sim)))); % this should be around 10;
ind_small_azi = find(azi_sim<delta_azi,n_rev+1,'last');
% index of requested revolutions
ind_last_rev  = ind_small_azi(1):ind_small_azi(end)-1;
% select force, azimuth and time based on this index
Fn_last_rev   = Fn(ind_last_rev,:);
azi_last_rev  = azi_sim(ind_last_rev);
t_sim         = D{:,1};
t_last_rev    = t_sim(ind_last_rev);

% Interpolation: columns of Fn_last_rev are interpolated to
% yield new columns at r_exp positions
Fn_int   = spline(r_sim,Fn_last_rev,r_exp);


%% loop over radial sections and do FFT for each section

figure(10)
colormap = get(gca,'ColorOrder');

% radial indices to plot:
r_index = 1:5;

% number of fourier coefficients to keep
n_keep = 3;

    
for k = 1:length(r_index)
    
    
    %% Fourier
    n    = length(azi_last_rev);
    dazi = mean(diff(azi_last_rev)); % in degrees
    dt   = mean(diff(t_last_rev)); % in seconds
    Fn_k   = Fn_int(:,r_index(k));
    % subtract the mean of the data (possible, not required)
%     Fn_mean = mean(Fn);
    Fn_pert = Fn_k; % - Fn_mean;
    % do the fourier transform
    % include scaling to get physical interpretable coefficients
    Fhat = fft(Fn_pert,n)/n;
    % get the power spectral density
    PSD  = Fhat.*conj(Fhat);

    % first half of frequencies contains all information, because the signal is
    % real, so c_k = c_{-k}
    % we therefore plot the one-sided (positive) frequency range only
    freqVals = (1/dt)*(0:floor(n/2)-1)'/n;
    
    % power in time and in frequency domain (should match)
    norm(Fn_k)^2/n;
    sum(PSD);

    % for plotting purposes, the fftshift can be useful:
    % Fhat_shift = fftshift(Fhat);
    % PSD_plot = Fhat_shift.*conj(Fhat_shift);
    % full frequency range:
    % freq = 1/(dt*n)*(0:n);
    % freq = (1/dt)*(-n/2:n/2-1)/n;
    
    % select indices with largest PSD by sorting the PSD
    [val,ind] = sort(PSD,'desc');
    %
    ind_select = ones(n,1);
    % select 2*n_keep indices, where the factor 2 is needed because we need the
    % coefficients associated with negative frequencies as well to do the inverse
    % transform
    ind_select(ind(2*n_keep:end)) = 0;
    % set other indices to 0
    Fhat_new = ind_select.*Fhat;
    % back to the time domain
    Fnew     = n*ifft(Fhat_new,n);
    
    % note: if we want physical meaning out of the Fourier coefficients
    % (amplitude, angle) we need to multiply by 2 if we don't
    % include the complex conjugates
    % below is with all coefficients:
    ind_keep = ind(1:2*n_keep-1);
    f_keep = Fhat(ind_keep);
    abs(f_keep);
    angle(f_keep);

    % alternatively, with only positive frequencies:
    ind_pos = ind(2:2:2*(n_keep-1));
    f_pos  = Fhat(ind_pos);
    abs(Fhat(ind(1)))
    abs(f_pos)*2
    angle(f_pos)    
    
    
    figure(9)
    semilogy(freqVals(1:end),PSD(1:floor(n/2)),'x-','Color',colormap(k,:))
    hold on
    semilogy(freqVals.*ind_select(1:floor(n/2)),PSD(1:floor(n/2)).*ind_select(1:floor(n/2)),'s','Color',colormap(k,:))
    
    figure(10)
    plot(t_last_rev,Fn_pert,'-','Color',colormap(k,:));
    hold on
    plot(t_last_rev,Fnew,'--','Color',colormap(k,:));
    
end

figure(9)
grid on
legend('Section 1','Section 1 - selected modes',...
    'Section 2','Section 2 - selected modes',...
    'Section 3','Section 3 - selected modes',...
    'Section 4','Section 4 - selected modes',...
    'Section 5','Section 5 - selected modes');
xlabel('Frequency [1/s]');
ylabel('Power spectral density');

figure(10)
grid
legend('Section 1','Section 1 - 3 modes',...
    'Section 2','Section 2 - 3 modes',...
    'Section 3','Section 3 - 3 modes',...
    'Section 4','Section 4 - 3 modes',...
    'Section 5','Section 5 - 3 modes');
xlabel('t [s]')
ylabel('Fn [N/m]');
title('Approximation of blade 1 forces with Fourier modes')



