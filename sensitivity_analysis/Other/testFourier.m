%% test Fourier representation of azimuth-dependent data
clearvars
close all

%% load some data
root_folder = pwd;
filename = fullfile('AEROmodule','NewMexico','current','output','B1n_BEM.txt');

% Read output data generated by AeroModule
D = readtable(filename,'HeaderLines', 4,"ReadVariableNames",true,...
    "PreserveVariableNames",true); % Reads the variable data from the
% specified .txt file
% column 1 is time,
% column 2 is azimuth,
% columns 3:end correspond to different radial locations
Fn = D{:,3:end};

% Radial stations
r_sim = str2double(D.Properties.VariableNames(3:end));
% the radial stations are expressed in % of the blade length,
% excluding the hub radius
% to compare to experiments, add the hub radius:
r_sim = r_sim + 0.21;


%% get a number of revolutions
n_rev = 4;

% radial stations of experimental data
r_exp = [0.25 0.35 0.6 0.82 0.92]*2.25;

% Use full (azimuth dependent) solution
% select a couple of revolutions by looking at where azimuth is smaller
% than a threshold value; the threshold value is taken as the minimum of the difference
% between azimuth angles
azi_sim       = D{:,2};
delta_azi     = floor(min(abs(diff(azi_sim)))); % this should be around 10;
ind_small_azi = find(azi_sim<delta_azi,n_rev+1,'last');
% index of requested revolutions
ind_last_rev  = ind_small_azi(1):ind_small_azi(end)-1;
% select force, azimuth and time based on this index
Fn_last_rev   = Fn(ind_last_rev,:);
azi_last_rev  = azi_sim(ind_last_rev);
t_sim         = D{:,1};
t_last_rev    = t_sim(ind_last_rev);

% Interpolation: columns of Fn_last_rev are interpolated to
% yield new columns at r_exp positions
Y   = spline(r_sim,Fn_last_rev,r_exp);


%% loop over radial sections and do FFT for each section

figure(10)
colormap = get(gca,'ColorOrder');

% radial indices to plot:
r_index = 1:5;

% number of fourier coefficients to keep
n_keep = 3;

    
for k = 1:length(r_index)
    
    
    %% Fourier
    n    = length(azi_last_rev); % should be even
    dazi = mean(diff(azi_last_rev)); % in degrees
    dt   = mean(diff(t_last_rev)); % in seconds
    Fn   = Fn_last_rev(:,r_index(k));
    % subtract the mean of the data
    Fn_mean = mean(Fn);
    Fn_pert = Fn - Fn_mean;
    % do the fourier transform
    Fhat = fft(Fn_pert,n);
    % get the power spectral density
    PSD  = Fhat.*conj(Fhat)/(n^2);

    % first half of frequencies contains all information, because the signal is
    % real, so c_k = c_{-k}
    % we therefore plot the one-sided (positive) frequency range only
    freqVals = (1/dt)*(0:n/2-1)'/n;
    
    
    % for plotting purposes, the fftshift can be useful:
    % Fhat_shift = fftshift(Fhat);
    % PSD_plot = Fhat_shift.*conj(Fhat_shift);
    % full frequency range:
    % freq = 1/(dt*n)*(0:n);
    % freq = (1/dt)*(-n/2:n/2-1)/n;
    
    % select indices with largest PSD by sorting the PSD
    [val,ind] = sort(PSD,'desc');
    %
    ind_select = ones(n,1);
    % select 2*n_keep indices, where the factor 2 is needed because we need the
    % coefficients associated with negative frequencies as well to do the inverse
    % transform
    ind_select(ind(2*n_keep+1:end)) = 0;
    % set other indices to 0
    Fhat_new = ind_select.*Fhat;
    % back to the time domain
    Fnew     = ifft(Fhat_new,n);
    
    figure(9)
    % we skip the first frequency, since we have removed the mean it is
    % machine precision 0 and pollutes the plot
    semilogy(freqVals(2:end),PSD(2:n/2),'x-','Color',colormap(k,:))
    hold on
    semilogy(freqVals.*ind_select(1:n/2),PSD(1:n/2).*ind_select(1:n/2),'s','Color',colormap(k,:))
    
    figure(10)
    plot(t_last_rev,Fn_pert,'-','Color',colormap(k,:));
    hold on
    plot(t_last_rev,Fnew,'--','Color',colormap(k,:));
    
end

figure(9)
grid on
legend('Section 1','Section 1 - selected modes',...
    'Section 2','Section 2 - selected modes',...
    'Section 3','Section 3 - selected modes',...
    'Section 4','Section 4 - selected modes',...
    'Section 5','Section 5 - selected modes');
xlabel('Frequency [1/s]');
ylabel('Power spectral density');

figure(10)
grid
legend('Section 1','Section 1 - 3 modes',...
    'Section 2','Section 2 - 3 modes',...
    'Section 3','Section 3 - 3 modes',...
    'Section 4','Section 4 - 3 modes',...
    'Section 5','Section 5 - 3 modes');
xlabel('t [s]')
ylabel('Fn [N/m]');
title('Approximation of blade 1 forces with Fourier modes (mean subtracted)')


%% simple example of  FFT and iFFT
n  = 50; % number of samples
t  = linspace(0,1,n)';
dt = t(2)-t(1);
freq = 1/dt; %sampling frequency should be at least 2*highest frequency in signal
f    = sin(2*pi*3*(t-0.4));% + sin(2*pi*120*t);
n    = length(t);
fhat = fft(f,n);
psd  = fhat.*conj(fhat)/(n^2);

% power in time and in frequency domain (should match)
norm(f)^2/n
sum(psd)

fVals = freq*(0:n/2-1)/n;
figure
semilogy(fVals,psd(1:n/2))

% select indices with largest PSD by sorting the PSD
[val,ind] = sort(psd,'desc');
%
ind_select = ones(n,1);
% select 2*n_keep indices, where the factor 2 is needed because we need the
% coefficients associated with negative frequencies as well to do the inverse
% transform
n_keep = 3;
ind_select(ind(2*n_keep+1:end)) = 0;
% set other indices to 0
fhat_new = ind_select.*fhat;
fnew    = ifft(fhat_new,n);

figure
plot(t,f);
hold on
plot(t,fnew);
