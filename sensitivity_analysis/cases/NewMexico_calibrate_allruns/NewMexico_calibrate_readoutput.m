function Y = NewMexico_calibrate_readoutput(output_dir,P)

switch P.FixedParameters.QoI
    
    case 'Sectional_normal_force'
        % in this case the QoI is a vector, returning the time-averaged force at
        % each section
        filename = fullfile(output_dir,'B1n_BEM.txt');
        
        % Read output data generated by AeroModule
        D = readtable(filename,'HeaderLines', 4,"ReadVariableNames",true,...
            "PreserveVariableNames",true); % Reads the variable data from the
        % specified .txt file
        % column 1 is time,
        % column 2 is azimuth,
        % columns 3:end correspond to different radial locations
        Fn = D{:,3:end};
        
        % Radial stations
        r_sim = str2double(D.Properties.VariableNames(3:end));
        % the radial stations are expressed in % of the blade length,
        % excluding the hub radius
        % to compare to experiments, add the hub radius:
        r_sim = r_sim + 0.21;
        
        
        
        % Locations of experimental data
        % These values are made available from NewMexico:
        r_exp = P.FixedParameters.r_exp; %2.25*[0.25 0.35 0.6 0.82 0.92]; % Measurement radial stations in percentage of blade length
        
        switch P.FixedParameters.QoI_type
            
            case 'mean'
                % Calculate mean
                Fn_mean = mean(Fn,1); % Mean (average in time) values at different radial stations
                
                % Interpolation
                Y   = spline(r_sim,Fn_mean,r_exp); % Interpolated data using spline
                
            case 'full'
                
                % number of revolutions to consider (counting backward)
                n_rev     = P.FixedParameters.n_rev;
                % number of Fourier coefficients to keep (including mean)
                % note: we get (n_fourier-1)*2 + 1 coefficients
                index_fourier = P.FixedParameters.index_fourier;
                % radial indices to consider:
                r_index   = P.FixedParameters.r_index;
                
                % Use full (azimuth dependent) solution
                % select only the last revolution
                t_sim     = D{:,1};
                azi_sim   = D{:,2};
                delta_azi = floor(min(abs(diff(azi_sim)))); % this should be around 10;
                ind_small_azi = find(azi_sim<delta_azi,n_rev+1,'last');
                % index of requested revolutions
                ind_last_rev  = ind_small_azi(1):ind_small_azi(end)-1;
                
                % select force, azimuth and time based on this index
                Fn_last_rev   = Fn(ind_last_rev,:);
                azi_last_rev  = azi_sim(ind_last_rev);
                
                % get the time step from the simulation data, it should
                % be constant (if not, we should interpolate to equidistant
                % timesteps to do the Fourier transform)
                t_last_rev    = t_sim(ind_last_rev);
                dt   = mean(diff(t_last_rev)); % in seconds
                
                % Interpolation: columns of Fn_last_rev are interpolated to
                % yield new columns at r_exp positions
                Fn_int   = spline(r_sim,Fn_last_rev,r_exp);
                
                
                % get the coefficients of the first 3 modes
                % the coefficients are ordered according to the PSD
                Fhat        = getFourierCoefficients(Fn_int); %,n_fourier);
                %                 ind_select = 2:2:2*(n_fourier-1);
                
                Y = [];
                n_r_index = length(r_index);
                % loop over radial indices
                for k=1:n_r_index
                    
                    % loop over modes
                    for mode = 1:length(index_fourier)
                        ind_select = index_fourier(mode);
                        Fcurr = Fhat(ind_select,r_index(k));
                        
                        % exception for the mean:
                        if (index_fourier(mode)==1) % this means the mean is requested
                            F_add = abs(Fcurr);
                        else
                            % even index => amplitude
                            if (mod(index_fourier(mode),2)==0)
                                F_add = 2*abs(Fcurr);
                            else % odd index => angle
                                F_add = angle(Fcurr);
                            end
                        end
                        
                        Y = [Y F_add];
                    end
                    
                    % add mean separately
%                     Fhat_mean = abs(Fhat(1,r_index(k)));
%                     Fhat_new  = Fhat(ind_select,r_index(k));
                    
                    % save the complex coefficients in terms of amplitude
                    % and phase angleei
                    % since we only store the positive frequencies, we need
                    % to multiply by 2 for the physical amplitudes
%                     Y = horzcat(Y,[Fhat_mean 2*abs(Fhat_new)' angle(Fhat_new)']);
                    
                end
                
                % alternative: interpolate to the azimuth positions of the
                % experimental data
                % use transpose to make interpolation of entire matrix
                % possible
                %                 azi_exp = P.FixedParameters.azi_exp; %
                %                 Y   = spline(azi_last_rev',Y',azi_exp)';
                % put all into a single row vector
                %                 Y   = Y(:)';
                
                
            otherwise
                error('QoI type unknown');
        end
        
    otherwise
        error(strcat('QoI type unknown'));
        
end