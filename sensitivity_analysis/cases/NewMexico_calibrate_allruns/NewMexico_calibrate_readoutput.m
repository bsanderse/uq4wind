function Y = NewMexico_calibrate_readoutput(output_dir,P)

switch P.FixedParameters.QoI
    
    case 'Sectional_normal_force'
        % in this case the QoI is a vector, returning the time-averaged force at
        % each section
        filename = fullfile(output_dir,'B1n_BEM.txt');
        
        % Read output data generated by AeroModule
        D = readtable(filename,'HeaderLines', 4,"ReadVariableNames",true,...
            "PreserveVariableNames",true); % Reads the variable data from the
        % specified .txt file
        % column 1 is time,
        % column 2 is azimuth,
        % columns 3:end correspond to different radial locations
        Fn = D{:,3:end};
        
        % Radial stations
        r_sim = str2double(D.Properties.VariableNames(3:end));
        % the radial stations are expressed in % of the blade length,
        % excluding the hub radius
        % to compare to experiments, add the hub radius:
        r_sim = r_sim + 0.21;             
        
        % Locations of experimental data
        % These values are made available from NewMexico:
        r_exp = P.FixedParameters.r_exp; 
        
        switch P.FixedParameters.QoI_type
            
            case 'mean'
                % Calculate mean
                Fn_mean = mean(Fn,1); % Mean (average in time) values at different radial stations
                
                % Interpolation
                Y   = spline(r_sim,Fn_mean,r_exp); % Interpolated data using spline
                
            case 'full'
                
                % number of revolutions to consider (counting backward)
                n_rev     = P.FixedParameters.n_rev;
                % index of Fourier coefficients to keep 
                index_fourier = P.FixedParameters.index_fourier;
                fourier_type  = P.FixedParameters.fourier_type;

                % radial indices to consider:
                r_index   = P.FixedParameters.r_index;
                
                % Use full (azimuth dependent) solution
                % select only the last revolution
                t_sim     = D{:,1};
                azi_sim   = D{:,2};
                delta_azi = floor(min(abs(diff(azi_sim)))); % this should be around 10;
                ind_small_azi = find(azi_sim<delta_azi,n_rev+1,'last');
                % index of requested revolutions
                ind_last_rev  = ind_small_azi(1):ind_small_azi(end)-1;
                
                % select force, azimuth and time based on this index
                Fn_last_rev   = Fn(ind_last_rev,:);
                azi_last_rev  = azi_sim(ind_last_rev);
                
                % get the time step from the simulation data, it should
                % be constant (if not, we should interpolate to equidistant
                % timesteps to do the Fourier transform)
                t_last_rev    = t_sim(ind_last_rev);
                dt   = mean(diff(t_last_rev)); % in seconds
                
                % Interpolation: columns of Fn_last_rev are interpolated to
                % yield new columns at r_exp positions
                Fn_int   = spline(r_sim,Fn_last_rev,r_exp);                
                
                % get the coefficients of the dominant modes
                % the coefficients are ordered according to the PSD
                % except the first entry, which is always the mean
                Fhat        = getFourierCoefficientsRealData(Fn_int); %,n_fourier);
                %                 ind_select = 2:2:2*(n_fourier-1);
                               
                % the convention is that index=1 indicates the mean
                % index=2 indicates amplitude first mode
                % index=3 indicates phase shift first mode
                % index=4 indicates amplitude second mode
                % alternative:
                Fcurr = Fhat(index_fourier,r_index);
                % even indices
                index_even = mod(index_fourier,2)==0;
                % odd indices, except 1 (which is the mean)
                index_odd  = mod(index_fourier,2)==1 & index_fourier>1; 
                % 
                Fout = zeros(size(Fcurr));
%                 switch fourier_type
%                     case 'amp_phase'
%                         % even index => amplitude
%                         Fcurr(index_even,r_index) = 2*abs(Fcurr(index_even,r_index));
%                         Fcurr(index_odd,r_index)  = angle(Fcurr(index_odd,r_index));
% 
%                     case 'real_imag'
%                         % even index => real part
%                         Fcurr(index_even,r_index) = 2*real(Fcurr(index_even,r_index));
%                         Fcurr(index_odd,r_index)  = 2*imag(Fcurr(index_odd,r_index));
%                     otherwise
%                         error('wrong specification of Fourier type');
%                 end
                switch fourier_type
                    case 'amp_phase'
                        % even index => amplitude
                        Fout(index_even,:) = 2*abs(Fcurr(index_even,:));
                        Fout(index_odd,:) = angle(Fcurr(index_odd,:));

                    case 'real_imag'
                        % even index => real part
                        Fout(index_even,:) = 2*real(Fcurr(index_even,:));
                        Fout(index_odd,:)  = 2*imag(Fcurr(index_odd,:));
                    otherwise
                        error('wrong specification of Fourier type');
                end
                % map from 2D to 1D:
                % [radial section 1 QoIs; radial section 2 QoIs; ...];
                % then make a row vector with .'
                Y = Fout(:).';
                                
                %                 figure(100)
%                 plot(t_last_rev,Fn_int(:,1),'-');
%                 hold on
%                 figure(101)
%                 plot(t_last_rev,Fn_int(:,2),'-');
%                 hold on
%                 figure(102)
%                 plot(t_last_rev,Fn_int(:,3),'-');
%                 hold on
                figure(103)
                plot(azi_last_rev,Fn_int(:,4),'-');
                hold on
                figure(104)
                plot(azi_last_rev,Fn_int(:,5),'-');
                hold on   
                % alternative: interpolate to the azimuth positions of the
                % experimental data
                % use transpose to make interpolation of entire matrix
                % possible
                %                 azi_exp = P.FixedParameters.azi_exp; %
                %                 Y   = spline(azi_last_rev',Y',azi_exp)';
                % put all into a single row vector
                %                 Y   = Y(:)';
                
                
            otherwise
                error('QoI type unknown');
        end
        
    otherwise
        error(strcat('QoI type unknown'));
        
end